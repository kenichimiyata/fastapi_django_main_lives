#!/usr/bin/env python3
"""
GPT-ENGINEERçµ±åˆãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¨GPT-ENGINEERã®é€£æºãƒ†ã‚¹ãƒˆ
"""

import os
import sys
import subprocess
import tempfile
import shutil
from pathlib import Path
from datetime import datetime

# GPT-ENGINEERã®ãƒ‘ã‚¹ã‚’è¿½åŠ 
sys.path.append('/workspaces/fastapi_django_main_live/gpt-engineer')

class GPTEngineerIntegrationTest:
    """GPT-ENGINEERçµ±åˆãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹"""
    
    def __init__(self):
        self.base_dir = Path('/workspaces/fastapi_django_main_live')
        self.gpt_engineer_dir = self.base_dir / 'gpt-engineer'
        self.test_output_dir = self.base_dir / 'test_generated_systems'
        
        # ãƒ†ã‚¹ãƒˆå‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        self.test_output_dir.mkdir(exist_ok=True)
    
    def create_test_prompt(self):
        """ãƒ†ã‚¹ãƒˆç”¨ã®ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä½œæˆ"""
        return {
            "title": "Simple FastAPI Hello World",
            "content": """
Create a simple FastAPI application with the following features:

1. A main.py file with FastAPI app
2. A single endpoint that returns "Hello, World!"
3. A GET endpoint /health that returns {"status": "ok"}
4. Include requirements.txt with fastapi and uvicorn
5. Add a simple README.md with usage instructions

The application should be simple and ready to run with:
- pip install -r requirements.txt
- uvicorn main:app --reload

Keep it minimal and functional.
            """.strip()
        }
    
    def simulate_gpt_engineer_execution(self, prompt_data):
        """GPT-ENGINEERå®Ÿè¡Œã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
        print(f"ğŸ¤– GPT-ENGINEERå®Ÿè¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹")
        print(f"ğŸ“ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: {prompt_data['title']}")
        
        # å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        project_name = "test_fastapi_hello"
        project_dir = self.test_output_dir / project_name
        
        if project_dir.exists():
            shutil.rmtree(project_dir)
        project_dir.mkdir(parents=True)
        
        # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆ
        files_to_create = {
            "main.py": '''
from fastapi import FastAPI

app = FastAPI(title="Hello World API", version="1.0.0")

@app.get("/")
async def hello_world():
    return {"message": "Hello, World!"}

@app.get("/health")
async def health_check():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
            '''.strip(),
            
            "requirements.txt": '''
fastapi==0.104.1
uvicorn[standard]==0.24.0
            '''.strip(),
            
            "README.md": '''
# Simple FastAPI Hello World

A minimal FastAPI application demonstrating basic API endpoints.

## Features

- Hello World endpoint (`/`)
- Health check endpoint (`/health`)
- Automatic API documentation

## Installation

```bash
pip install -r requirements.txt
```

## Usage

```bash
uvicorn main:app --reload
```

Then visit:
- API: http://localhost:8000
- Docs: http://localhost:8000/docs
- Health: http://localhost:8000/health

## Generated by GPT-ENGINEER

This application was automatically generated using GPT-ENGINEER integration system.
            '''.strip(),
            
            "Dockerfile": '''
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
            '''.strip(),
            
            ".gitignore": '''
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv
.env
            '''.strip()
        }
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
        for filename, content in files_to_create.items():
            file_path = project_dir / filename
            file_path.write_text(content)
            print(f"âœ… Created: {filename}")
        
        return {
            "project_dir": str(project_dir),
            "files_created": list(files_to_create.keys()),
            "status": "success"
        }
    
    def test_generated_system(self, result):
        """ç”Ÿæˆã•ã‚ŒãŸã‚·ã‚¹ãƒ†ãƒ ã®ãƒ†ã‚¹ãƒˆ"""
        print(f"\nğŸ§ª ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆé–‹å§‹")
        project_dir = Path(result["project_dir"])
        
        # ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
        required_files = ["main.py", "requirements.txt", "README.md"]
        for filename in required_files:
            file_path = project_dir / filename
            if file_path.exists():
                print(f"âœ… {filename} - å­˜åœ¨ç¢ºèª")
            else:
                print(f"âŒ {filename} - ãƒ•ã‚¡ã‚¤ãƒ«ãªã—")
                return False
        
        # main.pyã®æ§‹æ–‡ãƒã‚§ãƒƒã‚¯
        main_py = project_dir / "main.py"
        try:
            with open(main_py, 'r') as f:
                code = f.read()
            compile(code, main_py, 'exec')
            print(f"âœ… main.py - æ§‹æ–‡ãƒã‚§ãƒƒã‚¯é€šé")
        except SyntaxError as e:
            print(f"âŒ main.py - æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: {e}")
            return False
        
        # requirements.txtã®å†…å®¹ç¢ºèª
        req_file = project_dir / "requirements.txt"
        with open(req_file, 'r') as f:
            requirements = f.read()
        
        if "fastapi" in requirements and "uvicorn" in requirements:
            print(f"âœ… requirements.txt - å¿…è¦ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç¢ºèª")
        else:
            print(f"âŒ requirements.txt - å¿…è¦ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ä¸è¶³")
            return False
        
        print(f"âœ… å…¨ãƒ†ã‚¹ãƒˆé€šé")
        return True
    
    def simulate_github_upload(self, result):
        """GitHub ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³"""
        print(f"\nğŸ”— GitHubé€£æºã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³")
        
        project_dir = Path(result["project_dir"])
        repo_name = f"generated-{project_dir.name}-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        repo_url = f"https://github.com/your-username/{repo_name}"
        
        # GitåˆæœŸåŒ–ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        commands = [
            "git init",
            "git add .",
            'git commit -m "Initial commit - Generated by GPT-ENGINEER"',
            f"git remote add origin {repo_url}",
            "git push -u origin main"
        ]
        
        print(f"ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: {project_dir.name}")
        print(f"ğŸ”— ãƒªãƒã‚¸ãƒˆãƒªURL: {repo_url}")
        print(f"ğŸ“‹ å®Ÿè¡Œäºˆå®šã‚³ãƒãƒ³ãƒ‰:")
        for cmd in commands:
            print(f"  $ {cmd}")
        
        return {
            "repo_url": repo_url,
            "repo_name": repo_name,
            "commands": commands,
            "status": "simulated"
        }
    
    def run_full_integration_test(self):
        """å®Œå…¨çµ±åˆãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ"""
        print("ğŸš€ GPT-ENGINEERçµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹")
        print("=" * 60)
        
        # 1. ãƒ†ã‚¹ãƒˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ
        print("\n1ï¸âƒ£ ãƒ†ã‚¹ãƒˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ")
        prompt_data = self.create_test_prompt()
        print(f"   ã‚¿ã‚¤ãƒˆãƒ«: {prompt_data['title']}")
        
        # 2. GPT-ENGINEERå®Ÿè¡Œ
        print("\n2ï¸âƒ£ GPT-ENGINEERå®Ÿè¡Œ")
        result = self.simulate_gpt_engineer_execution(prompt_data)
        print(f"   ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {result['project_dir']}")
        print(f"   ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«æ•°: {len(result['files_created'])}")
        
        # 3. ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ
        print("\n3ï¸âƒ£ ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ")
        test_passed = self.test_generated_system(result)
        
        # 4. GitHubé€£æº
        print("\n4ï¸âƒ£ GitHubé€£æº")
        github_result = self.simulate_github_upload(result)
        
        # 5. çµæœã‚µãƒãƒªãƒ¼
        print("\n" + "=" * 60)
        print("ğŸ“Š çµ±åˆãƒ†ã‚¹ãƒˆçµæœ")
        print("=" * 60)
        
        status_items = [
            ("ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå‡¦ç†", "âœ… æˆåŠŸ"),
            ("ã‚·ã‚¹ãƒ†ãƒ ç”Ÿæˆ", "âœ… æˆåŠŸ" if result['status'] == 'success' else "âŒ å¤±æ•—"),
            ("å“è³ªãƒ†ã‚¹ãƒˆ", "âœ… é€šé" if test_passed else "âŒ å¤±æ•—"),
            ("GitHubé€£æº", "âœ… æº–å‚™å®Œäº†"),
            ("ç·åˆè©•ä¾¡", "âœ… æˆåŠŸ" if all([result['status'] == 'success', test_passed]) else "âŒ è¦æ”¹å–„")
        ]
        
        for item, status in status_items:
            print(f"{status} {item}")
        
        # 6. æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
        print(f"\nğŸ“ˆ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:")
        print(f"1. å®Ÿéš›ã®GPT-ENGINEER APIå‘¼ã³å‡ºã—å®Ÿè£…")
        print(f"2. GitHub APIèªè¨¼ã¨ãƒªãƒã‚¸ãƒˆãƒªä½œæˆ")
        print(f"3. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®å¼·åŒ–")
        print(f"4. å“è³ªãƒã‚§ãƒƒã‚¯ã®è‡ªå‹•åŒ–")
        print(f"5. é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…")
        
        return {
            "overall_status": "success" if all([result['status'] == 'success', test_passed]) else "failed",
            "prompt_data": prompt_data,
            "generation_result": result,
            "test_result": test_passed,
            "github_result": github_result
        }

def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ"""
    tester = GPTEngineerIntegrationTest()
    result = tester.run_full_integration_test()
    
    if result["overall_status"] == "success":
        print(f"\nğŸ‰ çµ±åˆãƒ†ã‚¹ãƒˆå®Œäº†ï¼ã‚·ã‚¹ãƒ†ãƒ ã¯æ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã¾ã™ã€‚")
    else:
        print(f"\nâš ï¸ çµ±åˆãƒ†ã‚¹ãƒˆã§å•é¡ŒãŒç™ºè¦‹ã•ã‚Œã¾ã—ãŸã€‚è©³ç´°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")

if __name__ == "__main__":
    main()
